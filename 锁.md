# 锁

`锁结构`

怎么解决`脏读`、`不可重复度`、`幻读`

> 方案一：读操作使用MVCC+写操作加锁
>
> 我们说过普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。



> 方案二：读、写操作都采用`加锁`



## 一致性读(快照读)，MVCC使用的就是

所有普通的select语句在`RC`、`RR`隔离级别下就是快照读

## 锁定读

**共享锁和独占锁**

- 共享锁：`Shared Locks`,S锁。在事务读取一条记录时，需要先获取该记录的`S锁`
- 独占锁(排他锁)：`Exclusive Locks`，X锁。在事务要改动一条记录时，需要先获取该记录的`X锁`。

| 兼容性 | `X`    | `S`    |
| ------ | ------ | ------ |
| `X`    | 不兼容 | 不兼容 |
| `S`    | 不兼容 | 兼容   |

**锁定读**

- 对读取的记录加S锁

```mysql
SELECT ... LOCK IN SHARE MODE;
```

- 对读取的记录加X锁

```mysql
SELECT ...FOR UPDAYE
```

**写操作**

- `Delete`
  - 对一条记录做`delete`操作的过程，先在`B+树`种定位到该条记录，然后获取这条记录的`X锁`，然后在执行`delete mark`操作者。
- `update`
  - 情况一：未修改该记录的健值并更新的列占用的存储空间在修改前后未发生变化。
    - 先定位在`B+树`中的位置，然后在获取该记录的`X锁`，最后在原记录的位置进行修改
  - 情况二：未修改该记录的键值并更新了的列占用的空间发生了变化。
    - 先定位在`B+树`中的位置，然后获取该记录的`X锁`，将该记录彻底删除掉（就是把该记录移入`垃圾链表`），最后插入一条新纪录。这个定位待修改记录在`B+树`中位置的过程看成是一个获取`X锁`的`锁定读`，新插入的记录由`insert`操作提供的`隐士锁`进行保护
  - 情况三：修改了该记录的键值，
    - 在原纪录上`delete`操作，在做`insert`操作
- `insert`

## 多粒度锁

表锁

意向共享锁：`Intention Shared Lock` ,简称`IS锁`。当事务准备在某条记录上加`S锁`时，需要先在`表级别`加一个`IS锁`。

意向独占锁：`Intention Exclusive Lock`，简称`IX锁`。当事务准备在某条记录上加`X锁`时，需要先在表级别加一个`IX锁`。

:imp:总结：

<font color=red>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的</font>

| 兼容性 | X      | IX     | S      | IS     |
| ------ | ------ | ------ | ------ | ------ |
| X      | 不兼容 | 不兼容 | 不兼容 | 不兼容 |
| IX     |        | 不兼容 | 不兼容 | 兼容   |
| S      |        |        | 兼容   | 兼容   |
| IS     |        |        |        | 兼容   |

### 其他存储引擎中的锁

对于`MyISAM`、`MEMORY`、`MERGE`这些存储引擎只支持表级锁，不支持事务。

`AUTO_INCREMENT`原理：

- 采用AUTO_INC锁，在插入时在表级别添加AUTO_INC锁，为插入的记录分配递增的值，执行结束释放锁。
- 轻量级锁：innodb_autoinc_lock_mode的系统变量来控制采用AUTO_INC锁还是轻量级锁

### InnoDB中的行级锁

- `Record Locks` 行锁

- `Gap Locks` 间隙锁

  - MySQL在`RR`隔离级别下，解决幻读问题。
    - 方案一：`MVCC`
    - 方案二：`Gap Locks`.(**gap锁仅仅为了防止插入幻读而提出**)给一条记录加`Gap锁`，不允许其他事务在该记录指定区间(页内最小记录，页内最大记录)内的记录插入。

- `Next-Key Locks`（=`Record Locks` +` Gap Locks`）保护该记录又阻止别的事务将新记录插入被保护记录前边的间隙

- `Insert Intention Locks`-`插入意向锁`。

  - `插入意向锁`并**不会阻塞别的事务**继续获取该记录上任何类型的锁

- 隐士锁

  - 场景一：聚簇索引中有`trx_id`隐藏列，比较当前`事务ID`和`trx_id`，是活跃的事务则创建一个`X锁`。
  - `二级索引`没有`trx_id`隐藏列，但在二级索引的页面的`Page Header`中有`PAGE_MAX_TRX_ID`属性，该属性代表该页面改动的最大的`事务ID`，如果`PAGE_MAX_TRX_ID` < `当前最小的活跃事务ID`，说明对该页面的事务都已经提交了。否则需要定位到对应的二级索引记录，`回表`找到聚簇索引记录重复场景一

  一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于`事务id`这个牛逼的东东的存在，相当于加了一个`隐式锁`。别的事务在对这条记录加`S锁`或者`X锁`时，由于`隐式锁`的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。



### InnoDB锁的内存结构

加锁场景分以下场景

- 在同一个事务中进行加锁操作
- 被解锁记录在同一个页面中
- 加锁的类型是一样
- 等待状态的是一样的

**锁结构**：

>- 锁锁在的`事务信息`
>  - 例如`事务ID的指针`
>- `索引信息`
>  - `索引的指针`
>- `表锁`/`行锁`信息
>  - `表锁`：哪个表的信息
>  - `行锁`：
>    - `Space ID`表空间
>    - `Page Number` 页号
>    - `n_bits` 对于行锁来说，一条记录对应一个比特位，一个页面中包含很多记录
>- `type_mode`
>  - `lock_mode`:锁模式 `IS锁`、`IX锁`、`S锁`、`X锁`、`AUTO-INC锁`
>  - `Lock_type`：锁类型`Lock_table（表锁）` `Lock_REC（行锁）`
>  - `Rec_lock_type`：行锁的具体类型。`next-key 锁`,` gap锁` ,`Record Locks`,` 插入意向锁`
>- 其他信息
>- 其他
>
>

